# 第三章 词法分析

> 简而言之，词法分析的任务就是从左到右逐个字符的对源程序进行扫描，产生一个个的单词符号

## 1. 对于词法分析器的要求

**功能：**输入源程序，输出单词符号

**单词符号的种类：**

* 基本字：begin、repeat
* 标识符：变量名、数组名、过程名
* 常数
* 运算符：+、-、\*、/、...
* 界符：逗号、分号、括号、空格

**输出单词的形式：**（单词种别，单词自身的值）

* **单词种别**通常用**整数编码**表示
  * 一码一符：**基本字**、**运算符**、**界符。**如：（while，-）
  * 多码一符：**标识符**、**常数。**如：（id，100）

**注：词法分析器作为一个独立子程序，但是其处理不作为一遍。并非词法分析器一遍扫描源程序，然后将结果交给语法分析器。**

![](.gitbook/assets/image%20%2811%29.png)

## 2. 词法分析器的设计

### **2.1 词法分析器的结构**

![&#x8BCD;&#x6CD5;&#x5206;&#x6790;&#x5668;&#x7684;&#x7ED3;&#x6784;](.gitbook/assets/image%20%2831%29.png)

### **2.2 输入、预处理**

**问题：**可能某一个单词长度超过了扫描缓冲区，多出缓冲区的部分只能重新加载到缓冲区中，会导致之前加入的内容丢失

**解决方法：**两个半区互补使用，单词的长度限制  = 半区的长度

### 2.3 单词符号的识别：超前搜索

**导致超前搜索的原因：**由于语言规则不够严格，程序员可以把基本字当做标识符使用等，导致词法分析器需要去扫描到该代词的前面，才可以确定单词的种类。

![](.gitbook/assets/image%20%2829%29.png)

对于第一行需要扫描到**逗号**才可以确定 DO 是基本字；对于第二行需要扫描到**点**才可以确定DO99K是标识符

**几点限制就可以不必使用超前搜索**

* **所有基本字都是保留字**；用户不能用它们作为标识符
* **基本字作为特殊的标识符来处理**，使用保留字表
* 基本字、标识符和常数（或标号）之间没有确定的运算符或界符作为间隔，则必须**使用一个空格作为间隔**

![](.gitbook/assets/image%20%2827%29.png)

### 2.4 状态转换图

**状态转换图是一张有限方向图**

* **结点**代表状态，用圆圈表示
* 状态之间用**箭弧**连接，箭弧上的标记（字符）代表射出该状态下可能出现的输入字符或者字符类
* 一张转换图只包含**有限个状态**，其中有一个为**初态**，**至少要有一个终态**
* \*\*\*\*![](.gitbook/assets/image%20%2825%29.png) ****

**状态转换图可用于识别（接收）一定的字符串**

* 若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记付连接成的字（串）等于 $$\alpha$$ ，则称 $$\alpha$$ 为该状态转换图所识别（接收）
* 识别标识符的状态转换图：![](.gitbook/assets/image%20%2834%29.png) 
* 识别整数的状态转换图：![](.gitbook/assets/image%20%2812%29.png) 
* **注：终态上一个 \* 代表到达终态时回退一个字符**

### 2.5 词法分析器的示例

**助记符：**直接用编码表示不便于记忆，因此用助记符来表示编码

![](.gitbook/assets/image%20%2830%29.png)

**状态转换图的实现**

思想：每个状态结点对应一小段程序

具体方法：

1. 对**不含回路的分叉结点**，可用一组`IF-THEN-ELSE`语句实现

   ![](.gitbook/assets/image%20%2816%29.png) 

   ```c
   GetChar( );
   if (IsLetter( ))
       {… 状态 j 的对应程序段… ;}
   else if (IsDigit( ))
       {… 状态 k 的对应程序段… ;}
   else if (ch=‘/’)
       {… 状态 l 的对应程序段… ;}
   else
       {… 错误处理… ;}
   ```

2. 对**含回路的状态结点**，可对应一段由 `WHILE` 结构和 `IF` 语句构成的程序

   ![](.gitbook/assets/image%20%2826%29.png) 

   ```c
   GetChar( );
   while (IsLetter( )or IsDigit( ))
       GetChar( );
   … 状态 j 的对应程序段…
   ```

3. **终态结点**表示识别出某种单词符号 `RETURN(C, VAL)` 

缺点：利用`WHILE`结构和`IF`语句列出所有情况，进行处理，这种方法一点都不灵活

**状态转换图的代码一般化**

* 变量 `curState` 用于保存现有的状态
* 用二维数组表示：`stateTrans[state][char]` 

```c
curState = 初态GetChar();
GetChar();
while( stateTrans[curState][ch] 有定义){
    //存在后继状态，读入、拼接
    Concat();
    //转换入下一状态，读入下一字符
    curState= stateTrans[curState][ch];
    if cur_state是终态 then 返回 strToken中的单词
    GetChar( );
}
```

## 3. 正规表达式与有限自动机

> 通过介绍词法分析器的设计和代码实现，发现不难，但是很繁琐，很多步骤都是有规律的，所以是否有方法可以自动产生词法分析程序！

### 3.1 正规式和正规集

* **正规集**可以用**正规表达式**（简称**正规式**）表示
* 正规式是表示正规集的一种方法
* 一个字集合是正规集，当且仅当它可以用正规式表示

> 一句话总结：**正规式**是抽象出的规则，**正规集**是根据正规式具体实现的集合
>
> 例如：正规式：x + 1（x 为 整数）；正规集：所有整数加一的式子构成的集合

递归定义

1. $$\epsilon$$ 和 $$\phi$$ 都是 $$\sum$$ 上的正规式，他们所表示的正规集为 $$\{ \epsilon \}$$ 和 $$\phi$$ 
2. 任何 $$a \in \sum$$ ， $$a$$ 是 $$\sum$$ 上的正规式，它所表示的正规集为 $$\{ a \}$$ 
3. 假定 $$e_1$$ 和 $$e_2$$ 都是 $$\sum$$ 上的正规式，他们所表示的正规集为 $$L(e_1)$$ 和 $$L(e_2)$$ ，则：

   * $$(e_1 \mid e_2)$$ 为正规式，正规集为 $$L(e_1)\bigcup L(e_2)$$ 
   * $$(e_1 \cdot e_2)$$ 为正规式，正规集为 $$L(e_1) L(e_2)$$ 
   * $$(e_1)^*$$ 为正规式，正规集为 $$(L(e_1))^*$$ 

   仅由**有限次**使用上述三步骤而定义的表达式才是 $$\sum$$ 上的正规式，仅有这些正规式表示的字集才是 $$\sum$$ 上的正规集

等价变形

* 交换律： $$e_1 \mid e_2 = e_2 \mid e_1$$ 
* 结合律： $$e_1 \mid (e_2 \mid e_3) = (e_1 \mid e_2) \mid e_3$$ 
* 结合律： $$e_1  (e_2  e_3) = (e_1  e_2 ) e_3$$ 
* 分配率： $$e_1 \mid (e_2 \mid e_3) = e_1e_2 \mid e_1 e_3$$ 
* 分配率： $$(e_1 \mid e_2) \mid e_3 = e_1e_3 \mid e_2 e_3$$ 
* $$e\epsilon = \epsilon e = e$$ 
* $$e_1e_2 <> e_2e_1$$ 

### 3.2 确定有限自动机（DFA）

确定有限自动机是**对状态转化图进行形式化表达**

$$(DFA)M = (S, \sum, f, S_0, F)$$ 其中：

1. $$S$$ ：有穷**状态集**
2. $$\sum$$ ：输入**字母表**（有穷）
3. $$f$$ ：状态转移函数，单值部分映射， $$f(S, a) = S'$$，当前状态 $$S$$ ，输入字符 $$a$$ ，下一状态 $$S'$$ 
4. $$S_0 \in S$$ 是**唯一**的一个**初态**
5. $$F \subseteq S$$ ：终态集（**可空**）

![](.gitbook/assets/image%20%2823%29.png)

### 3.3 非确定有限自动机（NFA）

$$(NFA)M = (S, \sum, f, S_0, F)$$ 其中：

1. $$S$$ ：有穷**状态集**
2. $$\sum$$ ：输入**字母表**（有穷）
3. $$f$$ ：状态转移函数，单值部分映射， $$f(S, a) = S'$$，通过输入相同的字符 $$a$$ ，下一状态可能会有多个
4. $$S_0 \in S$$ 非空**初态集合**
5. $$F \subseteq S$$ ：终态集（**可空**）

![](.gitbook/assets/image%20%2815%29.png)

### **3.4 DFA 和 NFA 的关系**

**区别：**

1. DFA 只有**一个**初态；NFA可以有**多个**初态
2. DFA 的弧上只能是一个**字符**；NFA 弧上的标记可以是 $$\sum ^*$$ 中的一个**字**（甚至是一个正规式）
3. DFA 的一个状态通过一个字符只能到达**唯一的下个状态**；NFA 中一个状态可以通过同一个字到达多**个不同的下个状态**

**联系：**

1. DFA 是 NFA 的特例
2. 对于任何两个有限自动机 $$M$$ 和 $$M'$$ ，如果 $$L(M) = L(M')$$ ，则称 $$M$$ 与 $$M'$$等价
3. **重要结论：**判定两个自动机等价性的算法存在
4. 对于每个NFA M 存在一个DFA M'，使得 $$L(M) = L(M')$$
5. DFA 与 NFA 描述能力相同！ 
6. NFA：易于人工设计；DFA：易于计算机使用

### 3.5 NFA 转换为 DFA

1. 添加新初态结点 $$X$$ 和终态结点 $$Y$$ ， $$X,Y  \notin S$$ ，从 $$X$$ 到 $$S_0$$ 中任意状态结点连一条 $$\epsilon $$ 箭弧，从 $$F$$ 中任意状态结点连一条 $$\epsilon $$ 箭弧到 $$Y$$ 

   ![](.gitbook/assets/image%20%2828%29.png) $$\longrightarrow$$ ![](.gitbook/assets/image%20%2819%29.png) 

2. 根据三条规则进行分裂，让箭弧上的标记变为单个字符

   * ![](.gitbook/assets/image%20%2817%29.png) 
   * ![](.gitbook/assets/image%20%2814%29.png) 
   * ![](.gitbook/assets/image%20%2821%29.png) 

   ![](.gitbook/assets/image%20%2819%29.png) $$\longrightarrow$$ ![](.gitbook/assets/image%20%2822%29.png) 

## 4. 词法分析器的自动产生 -- LEX 

