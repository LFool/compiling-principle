# 第三章 词法分析

> 简而言之，词法分析的任务就是从左到右逐个字符的对源程序进行扫描，产生一个个的单词符号

## 1. 对于词法分析器的要求

**功能：**输入源程序，输出单词符号

**单词符号的种类：**

* 基本字：begin、repeat
* 标识符：变量名、数组名、过程名
* 常数
* 运算符：+、-、\*、/、...
* 界符：逗号、分号、括号、空格

**输出单词的形式：**（单词种别，单词自身的值）

* **单词种别**通常用**整数编码**表示
  * 一码一符：**基本字**、**运算符**、**界符。**如：（while，-）
  * 多码一符：**标识符**、**常数。**如：（id，100）

**注：词法分析器作为一个独立子程序，但是其处理不作为一遍。并非词法分析器一遍扫描源程序，然后将结果交给语法分析器。**

![](.gitbook/assets/image%20%2811%29.png)

## 2. 词法分析器的设计

### **2.1 词法分析器的结构**

![&#x8BCD;&#x6CD5;&#x5206;&#x6790;&#x5668;&#x7684;&#x7ED3;&#x6784;](.gitbook/assets/image%20%2821%29.png)

### **2.2 输入、预处理**

**问题：**可能某一个单词长度超过了扫描缓冲区，多出缓冲区的部分只能重新加载到缓冲区中，会导致之前加入的内容丢失

**解决方法：**两个半区互补使用，单词的长度限制  = 半区的长度

### 2.3 单词符号的识别：超前搜索

**导致超前搜索的原因：**由于语言规则不够严格，程序员可以把基本字当做标识符使用等，导致词法分析器需要去扫描到该代词的前面，才可以确定单词的种类。

![](.gitbook/assets/image%20%2819%29.png)

对于第一行需要扫描到**逗号**才可以确定 DO 是基本字；对于第二行需要扫描到**点**才可以确定DO99K是标识符

**几点限制就可以不必使用超前搜索**

* **所有基本字都是保留字**；用户不能用它们作为标识符
* **基本字作为特殊的标识符来处理**，使用保留字表
* 基本字、标识符和常数（或标号）之间没有确定的运算符或界符作为间隔，则必须**使用一个空格作为间隔**

![](.gitbook/assets/image%20%2818%29.png)

### 2.4 状态转换图

**状态转换图是一张有限方向图**

* **结点**代表状态，用圆圈表示
* 状态之间用**箭弧**连接，箭弧上的标记（字符）代表射出该状态下可能出现的输入字符或者字符类
* 一张转换图只包含**有限个状态**，其中有一个为**初态**，**至少要有一个终态**
* \*\*\*\*![](.gitbook/assets/image%20%2816%29.png) ****

**状态转换图可用于识别（接收）一定的字符串**

* 若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记付连接成的字（串）等于 $$\alpha$$ ，则称 $$\alpha$$ 为该状态转换图所识别（接收）
* 识别标识符的状态转换图：![](.gitbook/assets/image%20%2824%29.png) 
* 识别整数的状态转换图：![](.gitbook/assets/image%20%2812%29.png) 
* **注：终态上一个 \* 代表到达终态时回退一个字符**

### 2.5 词法分析器的示例

**助记符：**直接用编码表示不便于记忆，因此用助记符来表示编码

![](.gitbook/assets/image%20%2820%29.png)

**状态转换图的实现**

思想：每个状态结点对应一小段程序

具体方法：

1. 对**不含回路的分叉结点**，可用一组`IF-THEN-ELSE`语句实现

   ![](.gitbook/assets/image%20%2814%29.png) 

   ```c
   GetChar( );
   if (IsLetter( ))
       {… 状态 j 的对应程序段… ;}
   else if (IsDigit( ))
       {… 状态 k 的对应程序段… ;}
   else if (ch=‘/’)
       {… 状态 l 的对应程序段… ;}
   else
       {… 错误处理… ;}
   ```

2. 对**含回路的状态结点**，可对应一段由 `WHILE` 结构和 `IF` 语句构成的程序

   ![](.gitbook/assets/image%20%2817%29.png) 

   ```c
   GetChar( );
   while (IsLetter( )or IsDigit( ))
       GetChar( );
   … 状态 j 的对应程序段…
   ```

3. **终态结点**表示识别出某种单词符号 `RETURN(C, VAL)` 

缺点：利用`WHILE`结构和`IF`语句列出所有情况，进行处理，这种方法一点都不灵活

**状态转换图的代码一般化**

* 变量 `curState` 用于保存现有的状态
* 用二维数组表示：`stateTrans[state][char]` 

```c
curState = 初态GetChar();
GetChar();
while( stateTrans[curState][ch] 有定义){
    //存在后继状态，读入、拼接
    Concat();
    //转换入下一状态，读入下一字符
    curState= stateTrans[curState][ch];
    if cur_state是终态 then 返回 strToken中的单词
    GetChar( );
}
```

## 3. 正规表达式与有限自动机

## 4. 词法分析器的自动产生 -- LEX 

