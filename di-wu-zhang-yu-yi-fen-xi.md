# 第五章 语义分析

## 1 属性文法

### **1.1 属性文法**

在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的 “值”（称为**属性**）

* **属性**代表与文法相关信息，如类型、值、代码序列、符号表内容等
* 属性可以进行计算和传递
* **语义规则**：对于文法的每个产生式都配备了一组属性的计算规则

### **1.2 属性**

* **综合属性**：“自下而上” 传递信息
* **继承属性**：“自上而下” 传递信息

在一个属性文法中，对应于每个产生式 $$A \rightarrow \alpha$$ 都有一套与之相关的**语义规则**，每条规则的形式为： $$b := f(c_1, c_2, \cdots, c_k)$$ ，这里， $$f$$ 是一个函数，而且或者：

1. b 是 A 的一个**综合属性** 并且  $$c_1, c_2, \cdots, c_k$$ 是产生式右边文法符号的属性
2. b 是产生式右边某个文法符号的一个**继承属性** 并且 $$c_1, c_2, \cdots, c_k$$ 是 A 或产生式右边任何文法符号的属性

### **1.3 说明**

* 终结符只有**综合属性**，由词法分析器提供
  * $$F \rightarrow digit$$ 
  * $$digit.lexval$$ 
* 非终结符既可有**综合属性**也可用**继承属性**，文法开始符号的所有继承属性作为属性计算前的初始值
  * $$F \rightarrow digit$$ 
  * $$F.val、digit.lexval$$ 
* 对于出现**产生式右边的继承属性**和**出现产生式左边的综合属性**都必须提供一个计算规则。属性计算规则只能使用相应产生式中的文法符号属性
  * $$F \rightarrow digit$$ 
  * $$F.val := digit.lexval$$ 
* 出现在**产生式左边的继承属性**和**出现在产生式右边的综合属性**不得由所给的产生式的属性计算规则计算，由其它产生式的属性规则计算或者由属性计算器的参数提供
* 语义规则所描述的工作可以包括属性计算、静态语义检查、符号表操作、代码生成等等

### 1.4 例子

非终结符考虑 A、B 和 C，其中：

* A 有一个继承属性 a 和一个综合属性 b；
* B 有综合属性 c；
* C 有继承属性 d；

产生式 $$A \rightarrow BC$$ 可能的规则有： $$C.d := B.c + 1 \\  A.b := A.a + B.c $$ ，而属性 A.a 和 B.c 在其他地方计算

### 1.5 总结

综合属性：只能由 等式右边 的 **子结点** 和 **本身** 计算

继承属性：只能由 等式左边 的 **父节点** 、**兄弟结点** 和 **本身** 计算

## 2. 基于属性文法的处理方法

输入串 $$\longrightarrow $$ 语法树 $$\longrightarrow $$ 按照语义规则计算属性

由源程序的语法结构所驱动的处理办法就是**语法制导翻译法**

**语义规则的计算**

* 产生代码
* 在符号表中存放信息
* 给出错误信息
* 执行任何其他动作

对输入符号串的**翻译**也就是根据语义规则进行**计算**的结果

### 2.1 依赖图

在一颗语法树中的结点的继承属性和综合属性之间的相互依赖关系可以由依赖图（有向图）来描述

为每一个包含过程调用的语义规则引入一个虚综合属性 b，这样把每一个语义规则都写成 $$b := f(c_1, c_2, \cdots, c_k)$$ 的形式

依赖图中为每一个属性设置一个结点，如果属性 b 依赖于属性 c，则从属性 c 的结点有一条有向边连到属性 b 的结点

**如：**

![](.gitbook/assets/image%20%2882%29.png)

**例子：**句子 $$real、id_1、id_2、id_3$$ 的带注释的语法树的依赖图

| 产生式 | 语义规则 | 添加边 |
| :---: | :---: | :---: |
| $$D \rightarrow TL$$  | $$L.in := T.type$$  | T 指向 L |
| $$T \rightarrow int$$  | $$T.type := integer$$  |  |
| $$T \rightarrow real$$  | $$T.type := real$$ |  |
| $$L \rightarrow L_1, id$$  | $$L_1.in := L.in \\ addtype(id.netry, L.in)$$ | $$L 指向 L_1 \\ L 和 id 指向 addtype$$  |
| $$L \rightarrow id$$  | $$addtype(id.netry, L.in)$$ | $$L 和 id 指向 addtype$$  |

![](.gitbook/assets/image%20%2880%29.png)

**良定义的属性文法**

* 如果一属性文法不存在属性之间的循环依赖关系，那么称该文法为良定义的

**属性的计算次序**

* 通过图的**拓扑排序**来确定属性的计算次序

输入串 $$\longrightarrow $$ 语法树 $$\longrightarrow $$ 依赖图 $$\longrightarrow $$ 语义规则计算次序



上面的例子的属性计算次序是：

 $$a_4 := real; \\  a_5 := a_4; \\  addtype(id_3.entry, a_5); \\  a_7 := a_5; \\  addtype(id_3.entry, a_7); \\  a_9 := a_7; \\  addtype(id_3.entry, a_9); $$ 

### 2.2 树遍历

通过树遍历的方法计算属性的值

* 假设语法树已建立，且树中已带有开始符号的继承属性和终结符的综合属性
* 以某种次序遍历语法，直至计算出所有属性
  * 深度优先，从左到右的遍历
* > while 还有未被计算的属性 do
  >
  >         visitNode\(S\) /\* S 是开始符号 \*/
  >
  > procedure visitNode\(N:Node\);
  >
  > begin
  >
  >         if N 是一个非终结符 then
  >
  >                 /\* 假设它的产生式为 $$N \rightarrow X_1 \cdots X_m$$ \*/
  >
  >                 for i := i to m do
  >
  >                         if $$X_i \in V_N$$ then /\* 即 $$X_i$$ 是非终结符 \*/
  >
  >                         begin
  >
  >                                 计算 $$X_i$$ 的所有能够计算的继承属性;
  >
  >                                 visitNode\( $$X_i$$ \)
  >
  >                         end;
  >
  >                 计算 N 的所有能够计算的综合属性
  >
  > end

### 2.3 一边扫描

* 一遍扫描的处理方法是在语法分析的同时计算属性值
* **L - 属性文法** 适合于一遍扫描的自上而下分析
* **S - 属性文法** 适合于一遍扫描的自下而上分析



**语法制导翻译法**

直观上就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则

按语义规则被计算的时机分为：

* 在自上而下语法分析中，一个产生式匹配输入串成功时
* 在自下而上语法分析中，一个产生式被用于进行归约时



**抽象语法树**

在语法树中去掉那些对翻译不必要的信息，从而获取更有效的源程序中间表达。这种经变换后的语法树称之为**抽象语法树**

![](.gitbook/assets/image%20%2878%29.png)

\*\*\*\*

**简历表达式的抽象语法树**

* $$mknode(op, left, right)$$ 建立一个运算符号结点，标号是 op，两个域指针 left 和 right 分别指向左子树和右子树
* $$mkleaf(id, entry)$$ 建立一个标识符结点，标号为 id，一个域 entry 指向标识符在符号表中的入口
* $$mkleaf(num, val)$$ 建立一个数结点，标号为 num，一个域 val 用于存放数的值

建立抽象语法树的语义规则

| 产生式 | 语义规则 |
| :---: | :---: |
| $$E \rightarrow E_1 + T$$  | $$E.nptr := mknode('+', E_1.nptr, T.nptr)$$  |
| $$E \rightarrow E_1 - T$$  | $$E.nptr := mknode('-', E_1.nptr, T.nptr)$$  |
| $$E \rightarrow T$$  | $$E.nptr := T.nptr$$  |
| $$T \rightarrow (E)$$  | $$T.nptr := E.nptr$$  |
| $$T \rightarrow id$$  | $$T.nptr := mkleaf(id, id.entry)$$  |
| $$T \rightarrow num$$  | $$T.nptr := mkleaf(num, num.val)$$  |

构造 $$a - 4 + c$$ 的抽象语法树

![](.gitbook/assets/image%20%2881%29.png)

## 3. S- 属性文法的自下而上计算

